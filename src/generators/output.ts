import type { Message, MessageData, ExportInfo } from "@/utils/types.js";
import type { CompilerConfig } from "@/utils/config.js";
import { generateLocaleType } from "@/utils/config.js";
import { generateFunctionName, processArrayItem } from "@/utils/helpers.js";
import type { ArrayItemInfo } from "@/utils/types.js";
import {
  generateMessageFunction,
  buildNamespaceObject,
  generateNamespaceCode,
} from "@/generators/functions.js";

/**
 * Generate compiled TypeScript output for a message path
 */
export function generateCompiledOutput(
  config: CompilerConfig,
  localeData: Record<string, Message[]>,
  folderPrefix: string = ""
): string {
  const lines: string[] = [];

  lines.push("// Auto-generated translation functions");
  lines.push("// Do not edit this file manually\n");

  const localeType = generateLocaleType(config);
  lines.push(`export type Locale = ${localeType};\n`);

  // Group messages by path across all locales
  const messagesByPath: Record<string, MessageData> = {};

  Object.entries(localeData).forEach(([locale, msgs]) => {
    msgs.forEach((msg) => {
      if (!messagesByPath[msg.path]) {
        messagesByPath[msg.path] = {
          params: msg.params,
          isArray: msg.isArray,
          values: {},
        };
      }
      messagesByPath[msg.path].values[locale] = msg.value;
    });
  });

  // Generate individual functions
  for (const [msgPath, data] of Object.entries(messagesByPath)) {
    const functionName = generateFunctionName(msgPath, folderPrefix);
    const { params, isArray, values } = data;

    // Generate JSDoc comment
    lines.push("/**");
    Object.entries(values).forEach(([locale, value]) => {
      if (isArray) {
        lines.push(` * @${locale} ${JSON.stringify(value)}`);
      } else {
        lines.push(` * @${locale} "${value}"`);
      }
    });
    lines.push(" */");

    // Generate function signature
    if (isArray) {
      const arrayInfo = Object.values(values)[0].map(processArrayItem);
      const needsParams = arrayInfo.some((info: ArrayItemInfo) => info.needsProcessing);

      if (needsParams) {
        lines.push(`export function ${functionName}(lang?: Locale, params?: any): any[] {`);
      } else {
        lines.push(`export function ${functionName}(lang?: Locale): any[] {`);
      }
    } else if (params.length > 0) {
      lines.push(`export function ${functionName}(lang?: Locale, params?: any): string {`);
    } else {
      lines.push(`export function ${functionName}(lang?: Locale): string | number | boolean {`);
    }

    lines.push(
      "  " + generateMessageFunction(config, values, params, isArray, true).replace(/\n/g, "\n  ")
    );
    lines.push("}\n");
  }

  // Generate namespace object
  const namespaceName = folderPrefix ? folderPrefix.replace(/\//g, "_") : "translations";
  const namespace = buildNamespaceObject(messagesByPath, folderPrefix);

  lines.push("/**");
  lines.push(" * Namespace object for grouped access to translations");
  lines.push(" * @example");
  if (folderPrefix) {
    lines.push(` * import { ${namespaceName} } from './messages'`);
    lines.push(` * const title = ${namespaceName}.page.title('en')`);
  } else {
    lines.push(` * import { translations } from './messages'`);
    lines.push(` * const title = translations.greeting('en', { name: 'Alice' })`);
  }
  lines.push(" */");
  lines.push(`export const ${namespaceName} = ${generateNamespaceCode(namespace, 0)} as const;`);

  return lines.join("\n");
}

/**
 * Generate centralized index file
 */
export function generateIndexFile(allExports: ExportInfo[]): string {
  const lines: string[] = [];

  lines.push("// Auto-generated centralized index");
  lines.push("// Re-exports all translation functions from all paths");
  lines.push("// Do not edit this file manually\n");

  const sorted = [...allExports].sort((a, b) => {
    if (a.path === "(root)") return -1;
    if (b.path === "(root)") return 1;
    return a.path.localeCompare(b.path);
  });

  for (const { path: msgPath, importPath, functions } of sorted) {
    lines.push(`// From: ${msgPath}`);
    lines.push(`export {`);
    functions.forEach((fn) => {
      lines.push(`  ${fn},`);
    });
    lines.push(`} from '${importPath}';\n`);
  }

  return lines.join("\n");
}

/**
 * Generate runtime utilities file
 */
export function generateRuntimeFile(config: CompilerConfig): string {
  const localeType = generateLocaleType(config);

  return (
    `// Runtime utilities for translations\n` +
    `export type Locale = ${localeType};\n\n` +
    `let currentLocale: Locale = "${config.defaultLocale}";\n\n` +
    `export function setLocale(l: Locale) { currentLocale = l; }\n` +
    `export function getLocale(): Locale { return currentLocale; }\n`
  );
}
