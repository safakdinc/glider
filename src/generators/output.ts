import type { Message, MessageData, ExportInfo } from "@/utils/types.js";
import type { CompilerConfig } from "@/utils/config.js";
import { generateLocaleType } from "@/utils/config.js";
import { generateFunctionName, processArrayItem } from "@/utils/helpers.js";
import type { ArrayItemInfo } from "@/utils/types.js";
import {
  generateMessageFunction,
  buildNamespaceObject,
  generateNamespaceCode,
} from "@/generators/functions.js";

/**
 * Generate compiled TypeScript output for a message path
 */
export function generateCompiledOutput(
  config: CompilerConfig,
  localeData: Record<string, Message[]>,
  folderPrefix: string = ""
): string {
  const lines: string[] = [];

  lines.push("// Auto-generated translation functions");
  lines.push("// Do not edit this file manually\n");

  const localeType = generateLocaleType(config);
  lines.push(`export type Locale = ${localeType};\n`);

  // Group messages by path across all locales
  const messagesByPath: Record<string, MessageData> = {};

  Object.entries(localeData).forEach(([locale, msgs]) => {
    msgs.forEach((msg) => {
      if (!messagesByPath[msg.path]) {
        messagesByPath[msg.path] = {
          params: msg.params,
          isArray: msg.isArray,
          values: {},
        };
      }
      messagesByPath[msg.path].values[locale] = msg.value;
    });
  });

  // Generate individual functions
  for (const [msgPath, data] of Object.entries(messagesByPath)) {
    const functionName = generateFunctionName(msgPath, folderPrefix);
    const { params, isArray, values } = data;

    // Generate JSDoc comment
    lines.push("/**");
    Object.entries(values).forEach(([locale, value]) => {
      if (isArray) {
        lines.push(` * @${locale} ${JSON.stringify(value)}`);
      } else {
        lines.push(` * @${locale} "${value}"`);
      }
    });
    lines.push(" */");

    // Generate function signature
    if (isArray) {
      const arrayInfo = Object.values(values)[0].map(processArrayItem);
      const needsParams = arrayInfo.some((info: ArrayItemInfo) => info.needsProcessing);

      if (needsParams) {
        lines.push(`export function ${functionName}(lang?: Locale, params?: any): any[] {`);
      } else {
        lines.push(`export function ${functionName}(lang?: Locale): any[] {`);
      }
    } else if (params.length > 0) {
      lines.push(`export function ${functionName}(lang?: Locale, params?: any): string {`);
    } else {
      lines.push(`export function ${functionName}(lang?: Locale): string | number | boolean {`);
    }

    lines.push(
      "  " + generateMessageFunction(config, values, params, isArray, true).replace(/\n/g, "\n  ")
    );
    lines.push("}\n");
  }

  // Generate namespace object
  const namespaceName = folderPrefix ? folderPrefix.replace(/\//g, "_") : "translations";
  const namespace = buildNamespaceObject(messagesByPath, folderPrefix);

  lines.push("/**");
  lines.push(" * Namespace object for grouped access to translations");
  lines.push(" * @example");
  if (folderPrefix) {
    lines.push(` * import { ${namespaceName} } from './messages'`);
    lines.push(` * const title = ${namespaceName}.page.title('en')`);
  } else {
    lines.push(` * import { translations } from './messages'`);
    lines.push(` * const title = translations.greeting('en', { name: 'Alice' })`);
  }
  lines.push(" */");
  lines.push(`export const ${namespaceName} = ${generateNamespaceCode(namespace, 0)} as const;`);

  return lines.join("\n");
}

/**
 * Generate centralized index file
 */
export function generateIndexFile(allExports: ExportInfo[]): string {
  const lines: string[] = [];

  lines.push("// Auto-generated centralized index");
  lines.push("// Re-exports all translation functions from all paths");
  lines.push("// Do not edit this file manually\n");

  const sorted = [...allExports].sort((a, b) => {
    if (a.path === "(root)") return -1;
    if (b.path === "(root)") return 1;
    return a.path.localeCompare(b.path);
  });

  for (const { path: msgPath, importPath, functions, namespaceName } of sorted) {
    lines.push(`// From: ${msgPath}`);
    lines.push(`export {`);
    functions.forEach((fn) => {
      lines.push(`  ${fn},`);
    });
    lines.push(`  ${namespaceName},`);
    lines.push(`} from '${importPath}';\n`);
  }

  // Export runtime utilities
  lines.push("// Runtime utilities");
  lines.push("export {");
  lines.push("  type Locale,");
  lines.push("  locales,");
  lines.push("  setLocale,");
  lines.push("  getLocale,");
  lines.push("  resolveTranslations,");
  lines.push("  type ResolvedTranslations,");
  lines.push("} from './runtime';\n");

  return lines.join("\n");
}

/**
 * Generate runtime utilities file
 */
export function generateRuntimeFile(config: CompilerConfig): string {
  const localeType = generateLocaleType(config);
  const localesArray = config.locales.map((l) => `"${l}"`).join(", ");

  return (
    `// Runtime utilities for translations\n` +
    `export type Locale = ${localeType};\n\n` +
    `/**\n` +
    ` * Available locales in the application\n` +
    ` */\n` +
    `export const locales: readonly Locale[] = [${localesArray}] as const;\n\n` +
    `let currentLocale: Locale = "${config.defaultLocale}";\n\n` +
    `export function setLocale(l: Locale) { currentLocale = l; }\n` +
    `export function getLocale(): Locale { return currentLocale; }\n\n` +
    `/**\n` +
    ` * Utility type that resolves all translation functions in a namespace to their return types.\n` +
    ` * Recursively converts function types to their return value types (string | number | boolean).\n` +
    ` *\n` +
    ` * @example\n` +
    ` * import { components_navbar } from './messages/components/navbar/messages';\n` +
    ` * import type { ResolvedTranslations } from './runtime';\n` +
    ` *\n` +
    ` * type NavbarTranslations = ResolvedTranslations<typeof components_navbar>;\n` +
    ` * // NavbarTranslations has same structure but all functions are replaced with their return types\n` +
    ` */\n` +
    `export type ResolvedTranslations<T> = {\n` +
    `  [K in keyof T]: T[K] extends (...args: any[]) => infer R\n` +
    `    ? R\n` +
    `    : T[K] extends object\n` +
    `    ? ResolvedTranslations<T[K]>\n` +
    `    : T[K];\n` +
    `};\n\n` +
    `/**\n` +
    ` * Recursively resolve all translation functions in a namespace object.\n` +
    ` * Converts function references to their resolved string/value equivalents.\n` +
    ` * Useful for SSR frameworks (like Astro) that need to serialize translations\n` +
    ` * before passing to client components.\n` +
    ` *\n` +
    ` * @example\n` +
    ` * import { components_navbar } from './messages/components/navbar/messages';\n` +
    ` * import { setLocale, resolveTranslations } from './runtime';\n` +
    ` * import type { ResolvedTranslations } from './runtime';\n` +
    ` *\n` +
    ` * setLocale('es');\n` +
    ` * const resolved: ResolvedTranslations<typeof components_navbar> = resolveTranslations(components_navbar);\n` +
    ` * // resolved.nav.solutions === "Soluciones" (string, not function)\n` +
    ` *\n` +
    ` * @param obj - The namespace object containing translation functions\n` +
    ` * @param params - Optional parameters to pass to parameterized translations\n` +
    ` * @returns A new object with the same structure, but all functions resolved to values\n` +
    ` */\n` +
    `export function resolveTranslations<T>(obj: T, params?: Record<string, any>): ResolvedTranslations<T> {\n` +
    `  if (typeof obj === 'function') {\n` +
    `    // Call the function, passing params if provided\n` +
    `    return (params ? obj(undefined, params) : obj()) as any;\n` +
    `  }\n` +
    `  if (typeof obj === 'object' && obj !== null) {\n` +
    `    const result: Record<string, any> = {};\n` +
    `    for (const key in obj) {\n` +
    `      // Recursively resolve nested objects/functions\n` +
    `      const nestedParams = params?.[key];\n` +
    `      result[key] = resolveTranslations((obj as any)[key], nestedParams);\n` +
    `    }\n` +
    `    return result as any;\n` +
    `  }\n` +
    `  return obj as any;\n` +
    `}\n`
  );
}
