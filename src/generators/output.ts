import type { Message, MessageData, ExportInfo } from "@/utils/types.js";
import type { CompilerConfig } from "@/utils/config.js";
import { generateLocaleType } from "@/utils/config.js";
import {
  generateFunctionName,
  processArrayItem,
  generateParamsTypeName,
  generateParamsInterface,
} from "@/utils/helpers.js";
import type { ArrayItemInfo } from "@/utils/types.js";
import {
  generateMessageFunction,
  buildNamespaceObject,
  generateNamespaceCode,
} from "@/generators/functions.js";

/**
 * Generate compiled TypeScript output for a message path
 */
export function generateCompiledOutput(
  config: CompilerConfig,
  localeData: Record<string, Message[]>,
  folderPrefix: string = ""
): string {
  const lines: string[] = [];

  lines.push("// Auto-generated translation functions");
  lines.push("// Do not edit this file manually\n");

  const localeType = generateLocaleType(config);
  lines.push(`export type Locale = ${localeType};\n`);

  // Group messages by path across all locales
  const messagesByPath: Record<string, MessageData> = {};

  Object.entries(localeData).forEach(([locale, msgs]) => {
    msgs.forEach((msg) => {
      if (!messagesByPath[msg.path]) {
        messagesByPath[msg.path] = {
          params: msg.params,
          isArray: msg.isArray,
          values: {},
        };
      }
      messagesByPath[msg.path].values[locale] = msg.value;
    });
  });

  // Generate parameter type interfaces first
  const generatedTypes = new Set<string>();
  for (const [msgPath, data] of Object.entries(messagesByPath)) {
    if (data.params.length > 0) {
      const typeName = generateParamsTypeName(msgPath, folderPrefix);
      if (!generatedTypes.has(typeName)) {
        const typeInterface = generateParamsInterface(typeName, data.params);
        if (typeInterface) {
          lines.push(typeInterface);
          generatedTypes.add(typeName);
        }
      }
    }
  }

  if (generatedTypes.size > 0) {
    lines.push(""); // Add blank line after type definitions
  }

  // First pass: identify all array paths and their items
  const arrayPaths = new Set<string>();
  const arrayItemObjects = new Map<string, any>(); // Store array item structures

  for (const [msgPath, data] of Object.entries(messagesByPath)) {
    if (data.isArray && !msgPath.match(/_\d+(?:_|$)/)) {
      arrayPaths.add(msgPath);

      // Analyze array items to see if they are objects
      const firstLocaleValue = Object.values(data.values)[0];
      if (Array.isArray(firstLocaleValue) && firstLocaleValue.length > 0) {
        const firstItem = firstLocaleValue[0];
        if (typeof firstItem === "object" && firstItem !== null && !Array.isArray(firstItem)) {
          // This array contains objects, store the structure
          arrayItemObjects.set(msgPath, Object.keys(firstItem));
        }
      }
    }
  }

  // Generate individual functions
  for (const [msgPath, data] of Object.entries(messagesByPath)) {
    const functionName = generateFunctionName(msgPath, folderPrefix);
    const { params, isArray, values } = data;

    // Check if this is a top-level array (not a nested array item property)
    const isTopLevelArray = isArray && !msgPath.match(/_\d+(?:_|$)/);

    if (isTopLevelArray) {
      // Generate a function that returns array of function references
      const arrayLength = Array.isArray(Object.values(values)[0])
        ? Object.values(values)[0].length
        : 0;

      // Generate JSDoc comment
      lines.push("/**");
      Object.entries(values).forEach(([locale, value]) => {
        lines.push(` * @${locale} ${JSON.stringify(value)}`);
      });
      lines.push(" */");

      // Generate function that returns array of item functions
      lines.push(`export function ${functionName}(): any[] {`);
      lines.push(`  return [`);
      for (let idx = 0; idx < arrayLength; idx++) {
        const itemFunctionName = generateFunctionName(`${msgPath}_${idx}`, folderPrefix);
        lines.push(`    ${itemFunctionName},`);
      }
      lines.push(`  ];`);
      lines.push(`}`);

      // Add translation metadata
      lines.push(`${functionName}._translations = ${JSON.stringify(values, null, 2)};`);
      lines.push("");

      // Generate individual array item functions if items are objects
      if (arrayItemObjects.has(msgPath)) {
        const itemKeys = arrayItemObjects.get(msgPath)!;

        for (let idx = 0; idx < arrayLength; idx++) {
          const itemFunctionName = generateFunctionName(`${msgPath}_${idx}`, folderPrefix);

          // Generate JSDoc for this item
          lines.push("/**");
          Object.entries(values).forEach(([locale, value]) => {
            const arrayValue = value as any[];
            lines.push(` * @${locale} ${JSON.stringify(arrayValue[idx])}`);
          });
          lines.push(" */");

          // Generate function that returns object with property functions
          lines.push(`export function ${itemFunctionName}(): any {`);
          lines.push(`  return {`);

          for (const key of itemKeys) {
            const propPath = `${msgPath}_${idx}_${key}`;
            const propData = messagesByPath[propPath];

            if (propData && propData.isArray) {
              // This property is an array, reference its array function
              const propFunctionName = generateFunctionName(propPath, folderPrefix);
              lines.push(`    ${key}: ${propFunctionName},`);
            } else {
              // This property is a simple value, reference its function
              const propFunctionName = generateFunctionName(propPath, folderPrefix);
              lines.push(`    ${key}: ${propFunctionName},`);
            }
          }

          lines.push(`  };`);
          lines.push(`}`);

          // Add metadata
          const itemValues: Record<string, any> = {};
          Object.entries(values).forEach(([locale, value]) => {
            const arrayValue = value as any[];
            itemValues[locale] = arrayValue[idx];
          });
          lines.push(`${itemFunctionName}._translations = ${JSON.stringify(itemValues, null, 2)};`);
          lines.push("");
        }
      }

      continue;
    }

    // Generate JSDoc comment
    lines.push("/**");
    Object.entries(values).forEach(([locale, value]) => {
      if (isArray) {
        lines.push(` * @${locale} ${JSON.stringify(value)}`);
      } else {
        lines.push(` * @${locale} "${value}"`);
      }
    });
    lines.push(" */");

    // Generate function signature
    if (isArray) {
      const arrayInfo = Object.values(values)[0].map(processArrayItem);
      const needsParams = arrayInfo.some((info: ArrayItemInfo) => info.needsProcessing);

      if (needsParams) {
        lines.push(
          `export function ${functionName}(options?: { lang?: Locale; [key: string]: any }): any[] {`
        );
      } else {
        lines.push(`export function ${functionName}(options?: { lang?: Locale }): any[] {`);
      }
    } else if (params.length > 0) {
      const paramsTypeName = generateParamsTypeName(msgPath, folderPrefix);
      lines.push(
        `export function ${functionName}(options: { lang?: Locale } & ${paramsTypeName}): string {`
      );
    } else {
      // Detect actual return type by checking all locale values
      const allValues = Object.values(values);
      const types = new Set(allValues.map((v) => typeof v));

      let returnType: string;
      if (types.size === 1) {
        // All values are the same type
        const singleType = Array.from(types)[0];
        returnType =
          singleType === "string"
            ? "string"
            : singleType === "number"
              ? "number"
              : singleType === "boolean"
                ? "boolean"
                : "string | number | boolean";
      } else {
        // Mixed types across locales - use union
        returnType = "string | number | boolean";
      }

      lines.push(`export function ${functionName}(options?: { lang?: Locale }): ${returnType} {`);
    }
    lines.push(
      "  " + generateMessageFunction(config, values, params, isArray, true).replace(/\n/g, "\n  ")
    );
    lines.push("}");

    // Add translation metadata for debugging
    lines.push(`// Add translation metadata for debugging`);
    lines.push(`${functionName}._translations = ${JSON.stringify(values, null, 2)};`);
    lines.push("");
  }

  // Generate namespace object
  const namespaceName = folderPrefix
    ? folderPrefix.replace(/\//g, "_").replace(/-/g, "_")
    : "translations";
  const namespace = buildNamespaceObject(messagesByPath, folderPrefix);

  lines.push("/**");
  lines.push(" * Namespace object for grouped access to translations");
  lines.push(" * @example");
  if (folderPrefix) {
    lines.push(` * import { ${namespaceName} } from './messages'`);
    lines.push(` * const title = ${namespaceName}.page.title('en')`);
  } else {
    lines.push(` * import { translations } from './messages'`);
    lines.push(` * const title = translations.greeting('en', { name: 'Alice' })`);
  }
  lines.push(" */");
  lines.push(`export const ${namespaceName} = ${generateNamespaceCode(namespace, 0)} as const;`);

  return lines.join("\n");
}

/**
 * Generate centralized index file
 */
export function generateIndexFile(allExports: ExportInfo[]): string {
  const lines: string[] = [];

  lines.push("// Auto-generated centralized index");
  lines.push("// Re-exports all translation functions from all paths");
  lines.push("// Do not edit this file manually\n");

  const sorted = [...allExports].sort((a, b) => {
    if (a.path === "(root)") return -1;
    if (b.path === "(root)") return 1;
    return a.path.localeCompare(b.path);
  });

  for (const { path: msgPath, importPath, functions, namespaceName } of sorted) {
    lines.push(`// From: ${msgPath}`);
    lines.push(`export {`);
    functions.forEach((fn) => {
      lines.push(`  ${fn},`);
    });
    lines.push(`  ${namespaceName},`);
    lines.push(`} from '${importPath}';\n`);
  }

  // Export runtime utilities
  lines.push("// Runtime utilities");
  lines.push("export {");
  lines.push("  type Locale,");
  lines.push("  locales,");
  lines.push("  setLocale,");
  lines.push("  getLocale,");
  lines.push("  resolveTranslations,");
  lines.push("  getTranslationDebugInfo,");
  lines.push("  type ResolvedTranslations,");
  lines.push("} from './runtime';\n");

  return lines.join("\n");
}

/**
 * Generate runtime utilities file
 */
export function generateRuntimeFile(config: CompilerConfig): string {
  const localeType = generateLocaleType(config);
  const localesArray = config.locales.map((l) => `"${l}"`).join(", ");

  return (
    `// Runtime utilities for translations\n` +
    `export type Locale = ${localeType};\n\n` +
    `/**\n` +
    ` * Translation function with metadata\n` +
    ` */\n` +
    `export interface TranslationFunction<T = any> {\n` +
    `  (options?: { lang?: Locale; [key: string]: any }): T;\n` +
    `  _translations?: Record<Locale, any>;\n` +
    `}\n\n` +
    `/**\n` +
    ` * Available locales in the application\n` +
    ` */\n` +
    `export const locales: readonly Locale[] = [${localesArray}] as const;\n\n` +
    `let currentLocale: Locale = "${config.defaultLocale}";\n\n` +
    `export function setLocale(l: Locale) { currentLocale = l; }\n` +
    `export function getLocale(): Locale { return currentLocale; }\n\n` +
    `/**\n` +
    ` * Debug helper to get translation metadata from resolved objects\n` +
    ` */\n` +
    `export function getTranslationDebugInfo(resolvedTranslation: any): any {\n` +
    `  return resolvedTranslation?._debugInfo || null;\n` +
    `}\n\n` +
    `/**\n` +
    ` * Helper type to check if a function parameter is required (non-optional)\n` +
    ` */\n` +
    `type IsRequired<T> = undefined extends T ? false : true;\n\n` +
    `/**\n` +
    ` * Utility type for resolved translations.\n` +
    ` * - Functions with required parameters (interpolation) are preserved as functions\n` +
    ` * - Functions with only optional parameters are resolved to their return types\n` +
    ` * - Nested objects and arrays are recursively processed\n` +
    ` *\n` +
    ` * @example\n` +
    ` * import { components_navbar } from './messages/components/navbar/messages';\n` +
    ` * import type { ResolvedTranslations } from './runtime';\n` +
    ` *\n` +
    ` * type NavbarTranslations = ResolvedTranslations<typeof components_navbar>;\n` +
    ` * const resolved = resolveTranslations(components_navbar);\n` +
    ` * // Functions without params: resolved to strings\n` +
    ` * // Functions with params: preserved as functions with proper types\n` +
    ` */\n` +
    `export type ResolvedTranslations<T> = \n` +
    `  T extends (...args: infer Args) => infer R\n` +
    `    ? Args extends [infer FirstArg]\n` +
    `      ? IsRequired<FirstArg> extends true\n` +
    `        ? T\n` +
    `        : R extends object\n` +
    `          ? ResolvedTranslations<R>\n` +
    `          : R\n` +
    `      : Args extends []\n` +
    `        ? R extends object\n` +
    `          ? ResolvedTranslations<R>\n` +
    `          : R\n` +
    `        : R extends object\n` +
    `          ? ResolvedTranslations<R>\n` +
    `          : R\n` +
    `    : T extends object\n` +
    `      ? { [K in keyof T]: ResolvedTranslations<T[K]> }\n` +
    `      : T;\n\n` +
    `/**\n` +
    ` * Recursively resolve all translation functions in a namespace object.\n` +
    ` * Converts function references to their resolved string/value equivalents.\n` +
    ` * Useful for SSR frameworks (like Astro) that need to serialize translations\n` +
    ` * before passing to client components.\n` +
    ` *\n` +
    ` * NOTE: All translation functions will be resolved to their values.\n` +
    ` * If your translations use parameter interpolation (e.g., {username}),\n` +
    ` * those functions cannot be resolved without their parameters.\n` +
    ` * Consider calling such functions directly instead of using resolveTranslations.\n` +
    ` *\n` +
    ` * @example\n` +
    ` * import { components_navbar } from './messages/components/navbar/messages';\n` +
    ` * import { setLocale, resolveTranslations } from './runtime';\n` +
    ` * import type { ResolvedTranslations } from './runtime';\n` +
    ` *\n` +
    ` * setLocale('es');\n` +
    ` * const resolved: ResolvedTranslations<typeof components_navbar> = resolveTranslations(components_navbar);\n` +
    ` * // resolved.nav.solutions === "Soluciones" (string, not function)\n` +
    ` *\n` +
    ` * @param obj - The namespace object containing translation functions\n` +
    ` * @param params - Optional parameters to pass to parameterized translations\n` +
    ` * @returns A new object with the same structure, but all functions resolved to values\n` +
    ` */\n` +
    `export function resolveTranslations<T>(obj: T, params?: Record<string, any>): ResolvedTranslations<T> {\n` +
    `  if (typeof obj === 'function') {\n` +
    `    const fn = obj as any as TranslationFunction;\n` +
    `    \n` +
    `    // Check if the function has interpolation placeholders (e.g., {name}, {count})\n` +
    `    // by inspecting the _translations metadata. If placeholders are found,\n` +
    `    // return the function itself so it can be called with parameters at runtime.\n` +
    `    const meta = (fn as any)?._translations;\n` +
    `    const hasPlaceholders = Boolean(\n` +
    `      meta && Object.values(meta).some((v: any) => typeof v === 'string' && /{[^}]+}/.test(v))\n` +
    `    );\n` +
    `    \n` +
    `    if (hasPlaceholders) {\n` +
    `      // Return the function itself for parameterized translations\n` +
    `      return fn as any;\n` +
    `    }\n` +
    `    \n` +
    `    // Safe to call: no interpolation placeholders detected\n` +
    `    const resolvedValue = params ? fn(params) : fn();\n` +
    `    \n` +
    `    // Check if the resolved value is a complex structure (array/object) that needs further resolution\n` +
    `    if (typeof resolvedValue === 'object' && resolvedValue !== null) {\n` +
    `      // The function returned an array or object, recursively resolve it\n` +
    `      return resolveTranslations(resolvedValue, params) as any;\n` +
    `    }\n` +
    `    \n` +
    `    // Return primitive values directly (string, number, boolean)\n` +
    `    // This ensures compatibility with React and other frameworks that expect primitives\n` +
    `    return resolvedValue as any;\n` +
    `  }\n` +
    `  if (Array.isArray(obj)) {\n` +
    `    // Handle arrays - resolve each item\n` +
    `    return obj.map((item, index) => {\n` +
    `      const nestedParams = Array.isArray(params) ? params[index] : params?.[index];\n` +
    `      return resolveTranslations(item, nestedParams);\n` +
    `    }) as any;\n` +
    `  }\n` +
    `  if (typeof obj === 'object' && obj !== null) {\n` +
    `    const result: Record<string, any> = {};\n` +
    `    for (const key in obj) {\n` +
    `      // Recursively resolve nested objects/functions\n` +
    `      const nestedParams = params?.[key];\n` +
    `      result[key] = resolveTranslations((obj as any)[key], nestedParams);\n` +
    `    }\n` +
    `    return result as any;\n` +
    `  }\n` +
    `  return obj as any;\n` +
    `}\n`
  );
}
